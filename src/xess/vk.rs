/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
pub struct _xess_vk_image_view_info {
    pub imageView: VkImageView,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
    pub format: VkFormat,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
}
impl Default for _xess_vk_image_view_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xess_vk_image_view_info = _xess_vk_image_view_info;
#[doc = " @brief Execution parameters for XeSS Vulkan."]
#[repr(C)]
pub struct _xess_vk_execute_params_t {
    #[doc = " Input color texture. Must be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state."]
    pub colorTexture: xess_vk_image_view_info,
    #[doc = " Input motion vector texture. Must be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state."]
    pub velocityTexture: xess_vk_image_view_info,
    #[doc = " Optional depth texture. Required if XESS_INIT_FLAG_HIGH_RES_MV has not been specified.\n Must be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state."]
    pub depthTexture: xess_vk_image_view_info,
    #[doc = " Optional 1x1 exposure scale texture. Required if XESS_INIT_FLAG_EXPOSURE_TEXTURE has been\n specified. Must be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state"]
    pub exposureScaleTexture: xess_vk_image_view_info,
    #[doc = " Optional responsive pixel mask texture. Required if XESS_INIT_FLAG_RESPONSIVE_PIXEL_MASK\n has been specified. Must be in VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL state"]
    pub responsivePixelMaskTexture: xess_vk_image_view_info,
    #[doc = " Output texture in target resolution. Must be in VK_IMAGE_LAYOUT_GENERAL state."]
    pub outputTexture: xess_vk_image_view_info,
    #[doc = " Jitter X coordinate in the range [-0.5, 0.5]."]
    pub jitterOffsetX: f32,
    #[doc = " Jitter Y coordinate in the range [-0.5, 0.5]."]
    pub jitterOffsetY: f32,
    #[doc = " Optional input color scaling. Default is 1."]
    pub exposureScale: f32,
    #[doc = " Resets the history accumulation in this frame."]
    pub resetHistory: u32,
    #[doc = " Input color width."]
    pub inputWidth: u32,
    #[doc = " Input color height."]
    pub inputHeight: u32,
    #[doc = " Base coordinate for the input color in the texture. Default is (0,0)."]
    pub inputColorBase: xess_coord_t,
    #[doc = " Base coordinate for the input motion vector in the texture.  Default is (0,0)."]
    pub inputMotionVectorBase: xess_coord_t,
    #[doc = " Base coordinate for the input depth in the texture. Default is (0,0)."]
    pub inputDepthBase: xess_coord_t,
    #[doc = " Base coordinate for the input responsive pixel mask in the texture. Default is (0,0)."]
    pub inputResponsiveMaskBase: xess_coord_t,
    #[doc = " Reserved parameter."]
    pub reserved0: xess_coord_t,
    #[doc = " Base coordinate for the output color.  Default is (0,0)."]
    pub outputColorBase: xess_coord_t,
}
impl Default for _xess_vk_execute_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Execution parameters for XeSS Vulkan."]
pub type xess_vk_execute_params_t = _xess_vk_execute_params_t;
#[doc = " @brief Initialization parameters for XeSS VK."]
#[repr(C)]
pub struct _xess_vk_init_params_t {
    #[doc = " Output width and height."]
    pub outputResolution: xess_2d_t,
    #[doc = " Quality setting"]
    pub qualitySetting: xess_quality_settings_t,
    #[doc = " Initialization flags."]
    pub initFlags: u32,
    #[doc = " Specifies the node mask for internally created resources on\n multi-adapter systems."]
    pub creationNodeMask: u32,
    #[doc = " Specifies the node visibility mask for internally created resources\n on multi-adapter systems."]
    pub visibleNodeMask: u32,
    #[doc = " Optional externally allocated buffer memory for XeSS. If VK_NULL_HANDLE the\n memory is allocated internally. If provided, the memory must be allocated from\n memory type that supports allocating buffers. The memory type should be DEVICE_LOCAL.\n This memory is not accessed by the CPU."]
    pub tempBufferHeap: VkDeviceMemory,
    #[doc = " Offset in the externally allocated memory for temporary buffer storage."]
    pub bufferHeapOffset: u64,
    #[doc = " Optional externally allocated texture memory for XeSS. If VK_NULL_HANDLE the\n memory is allocated internally. If provided, the memory must be allocated from\n memory type that supports allocating textures. The memory type should be DEVICE_LOCAL.\n This memory is not accessed by the CPU."]
    pub tempTextureHeap: VkDeviceMemory,
    #[doc = " Offset in the externally allocated memory for temporary texture storage."]
    pub textureHeapOffset: u64,
    #[doc = " Optional pipeline cache. If not VK_NULL_HANDLE will be used for pipeline creation."]
    pub pipelineCache: VkPipelineCache,
}
impl Default for _xess_vk_init_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Initialization parameters for XeSS VK."]
pub type xess_vk_init_params_t = _xess_vk_init_params_t;
#[repr(C)]
pub struct _xess_vk_resource_to_dump_desc_t {
    pub image: VkImage,
    pub buffer: VkBuffer,
    pub image_format: VkFormat,
    pub width: u64,
    pub height: u32,
    pub image_layout: VkImageLayout,
    pub image_array_size: u32,
    pub image_depth: u32,
}
impl Default for _xess_vk_resource_to_dump_desc_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xess_vk_resource_to_dump_desc_t = _xess_vk_resource_to_dump_desc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xess_vk_resources_to_dump_t {
    #[doc = " Total resource count. In case it equal to zero content of other structure members is undefined."]
    pub resource_count: u32,
    #[doc = " Pointer to an internal array of Vulkan resource descriptions (VkImage or VkBuffer). Array length is `resource_count`."]
    pub resources: *const _xess_vk_resource_to_dump_desc_t,
    #[doc = " Pointer to an internal array of Vulkan resource names. Array length is `resource_count`."]
    pub resource_names: *const *const ::std::os::raw::c_char,
    pub as_tensor: *const u32,
    pub border_pixels_to_skip_count: *const u32,
    pub tensor_channel_count: *const u32,
    pub tensor_width: *const u32,
    pub tensor_height: *const u32,
}
impl Default for _xess_vk_resources_to_dump_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xess_vk_resources_to_dump_t = _xess_vk_resources_to_dump_t;
pub struct Functions {
    __library: ::libloading::Library,
    pub xessVKGetRequiredInstanceExtensions: unsafe extern "C" fn(
        instanceExtensionsCount: *mut u32,
        instanceExtensions: *mut *const *const ::std::os::raw::c_char,
        minVkApiVersion: *mut u32,
    ) -> xess_result_t,
    pub xessVKGetRequiredDeviceExtensions: unsafe extern "C" fn(
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        deviceExtensionsCount: *mut u32,
        deviceExtensions: *mut *const *const ::std::os::raw::c_char,
    ) -> xess_result_t,
    pub xessVKGetRequiredDeviceFeatures: unsafe extern "C" fn(
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        features: *mut *mut ::std::os::raw::c_void,
    ) -> xess_result_t,
    pub xessVKCreateContext: unsafe extern "C" fn(
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        device: VkDevice,
        phContext: *mut xess_context_handle_t,
    ) -> xess_result_t,
    pub xessVKBuildPipelines: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pipelineCache: VkPipelineCache,
        blocking: bool,
        initFlags: u32,
    ) -> xess_result_t,
    pub xessVKInit: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pInitParams: *const xess_vk_init_params_t,
    ) -> xess_result_t,
    pub xessVKGetInitParams: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pInitParams: *mut xess_vk_init_params_t,
    ) -> xess_result_t,
    pub xessVKExecute: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        commandBuffer: VkCommandBuffer,
        pExecParams: *const xess_vk_execute_params_t,
    ) -> xess_result_t,
    pub xessVKGetResourcesToDump: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pResourcesToDump: *mut *mut xess_vk_resources_to_dump_t,
    ) -> xess_result_t,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let xessVKGetRequiredInstanceExtensions = __library
            .get(b"xessVKGetRequiredInstanceExtensions\0")
            .map(|sym| *sym)?;
        let xessVKGetRequiredDeviceExtensions = __library
            .get(b"xessVKGetRequiredDeviceExtensions\0")
            .map(|sym| *sym)?;
        let xessVKGetRequiredDeviceFeatures = __library
            .get(b"xessVKGetRequiredDeviceFeatures\0")
            .map(|sym| *sym)?;
        let xessVKCreateContext = __library.get(b"xessVKCreateContext\0").map(|sym| *sym)?;
        let xessVKBuildPipelines = __library.get(b"xessVKBuildPipelines\0").map(|sym| *sym)?;
        let xessVKInit = __library.get(b"xessVKInit\0").map(|sym| *sym)?;
        let xessVKGetInitParams = __library.get(b"xessVKGetInitParams\0").map(|sym| *sym)?;
        let xessVKExecute = __library.get(b"xessVKExecute\0").map(|sym| *sym)?;
        let xessVKGetResourcesToDump = __library
            .get(b"xessVKGetResourcesToDump\0")
            .map(|sym| *sym)?;
        Ok(Functions {
            __library,
            xessVKGetRequiredInstanceExtensions,
            xessVKGetRequiredDeviceExtensions,
            xessVKGetRequiredDeviceFeatures,
            xessVKCreateContext,
            xessVKBuildPipelines,
            xessVKInit,
            xessVKGetInitParams,
            xessVKExecute,
            xessVKGetResourcesToDump,
        })
    }
    #[doc = " @addtogroup xess-vulkan XeSS VK API exports\n @{\n/\n/**\n @brief Get required extensions for Vulkan instance that would run XeSS.\n This function must be called to get instance extensions need by XeSS. These\n extensions must be enabled in subsequent vkCreateInstance call, that would create a VkInstance\n object to be passed to @ref xessVKCreateContext\n @param[out] instanceExtensionsCount returns a count of instance extensions to be enabled in Vulkan instance\n @param[out] instanceExtensions returns a pointer to an array of \\p instanceExtensionsCount required extension names.\n             The memory used by the array is owned by the XeSS library and should not be freed by the application.\n @param[out] minVkApiVersion The Vulkan API version that XeSS would use. When calling vkCreateInstance, the application\n             should set VkApplicationInfo.apiVersion to value greater or equal to \\p minVkApiVersion\n @return XeSS return status code."]
    pub unsafe fn xessVKGetRequiredInstanceExtensions(
        &self,
        instanceExtensionsCount: *mut u32,
        instanceExtensions: *mut *const *const ::std::os::raw::c_char,
        minVkApiVersion: *mut u32,
    ) -> xess_result_t {
        (self.xessVKGetRequiredInstanceExtensions)(
            instanceExtensionsCount,
            instanceExtensions,
            minVkApiVersion,
        )
    }
    #[doc = " @brief Get required extensions for Vulkan device that would run XeSS.\n This function must be called to get device extensions need by XeSS. These\n extensions must be enabled in subsequent vkCreateDevice call, that would create a VkDevice\n object to be passed to @ref xessVKCreateContext\n @param instance A VkInstance object created by the user\n @param physicalDevice A VkPhysicalDevice selected by the user from instance\n @param[out] deviceExtensionsCount returns a count of device extensions to be enabled in Vulkan device\n @param[out] deviceExtensions returns a pointer to an array of \\p deviceExtensionsCount required extension names\n            The memory used by the array is owned by the XeSS library and should not be freed by the application.\n @return XeSS return status code."]
    pub unsafe fn xessVKGetRequiredDeviceExtensions(
        &self,
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        deviceExtensionsCount: *mut u32,
        deviceExtensions: *mut *const *const ::std::os::raw::c_char,
    ) -> xess_result_t {
        (self.xessVKGetRequiredDeviceExtensions)(
            instance,
            physicalDevice,
            deviceExtensionsCount,
            deviceExtensions,
        )
    }
    #[doc = " @brief Get required features for Vulkan device that would run XeSS.\n This function must be called to get device features need by XeSS. These\n features must be enabled in subsequent vkCreateDevice call, that would create a VkDevice\n object to be passed to @ref xessVKCreateContext.\n @param instance A VkInstance object created by the user\n @param physicalDevice A VkPhysicalDevice selected by the user from instance\n @param[out] features a pointer to writable chain of feature structures, that this function would patch\n             with required features, by filling required fields and attaching new structures to the chain if needed.\n             The returned pointer should be passed to vkCreateDevice as pNext chain of VkDeviceCreateInfo structure.\n             If null is passed, than the function constructs a new structure chain that should be merged\n             into the chain that application would use with VkDeviceCreateInfo, with application responsibility to\n             avoid any duplicates with its own structures.\n\n             It is an error to chain VkDeviceCreateInfo structure with not null pEnabledFeatures field, as this field is const\n             and cannot be patched by this function. VkPhysicalDeviceFeatures2 structure should be used instead.\n\n             The memory used by the structures added by this funtion to the chain is owned by the XeSS library and\n             should not be freed by the application.\n @return XeSS return status code."]
    pub unsafe fn xessVKGetRequiredDeviceFeatures(
        &self,
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        features: *mut *mut ::std::os::raw::c_void,
    ) -> xess_result_t {
        (self.xessVKGetRequiredDeviceFeatures)(instance, physicalDevice, features)
    }
    #[doc = " @brief Create an XeSS VK context.\n @param instance A VkInstance object created by the user\n @param physicalDevice A VkPhysicalDevice selected by the user from instance\n @param device A VK device created by the user from physicalDevice\n @param[out] phContext Returned xess context handle.\n @return XeSS return status code."]
    pub unsafe fn xessVKCreateContext(
        &self,
        instance: VkInstance,
        physicalDevice: VkPhysicalDevice,
        device: VkDevice,
        phContext: *mut xess_context_handle_t,
    ) -> xess_result_t {
        (self.xessVKCreateContext)(instance, physicalDevice, device, phContext)
    }
    #[doc = " @brief Initiates pipeline build process\n This function can only be called between @ref xessVKCreateContext and\n @ref xessVKInit\n This call initiates build of Vulkan pipelines and kernel compilation\n This call can be blocking (if @p blocking set to true) or non-blocking.\n In case of non-blocking call library will wait for pipeline build on call to\n @ref xessVKInit\n If @p pipelineCache passed to this call - same pipeline library must be passed\n to @ref xessVKInit\n\n @param hContext The XeSS context handle.\n @param pipelineCache Optional pointer to pipeline library for pipeline caching.\n @param blocking Wait for kernel compilation and pipeline creation to finish or not\n @param initFlags Initialization flags. *Must* be identical to flags passed to @ref xessVKInit"]
    pub unsafe fn xessVKBuildPipelines(
        &self,
        hContext: xess_context_handle_t,
        pipelineCache: VkPipelineCache,
        blocking: bool,
        initFlags: u32,
    ) -> xess_result_t {
        (self.xessVKBuildPipelines)(hContext, pipelineCache, blocking, initFlags)
    }
    #[doc = " @brief Initialize XeSS VK.\n This is a blocking call that initializes XeSS and triggers internal\n resources allocation and JIT for the XeSS kernels. The user must ensure that\n any pending command lists are completed before re-initialization. When\n During initialization, XeSS can create staging buffers and copy queues to\n upload internal data. These will be destroyed at the end of initialization.\n\n @note XeSS supports devices starting from VK_RESOURCE_HEAP_TIER_1, which means\n that buffers and textures can not live in the same resource heap.\n\n @param hContext: The XeSS context handle.\n @param pInitParams: Initialization parameters.\n @return XeSS return status code."]
    pub unsafe fn xessVKInit(
        &self,
        hContext: xess_context_handle_t,
        pInitParams: *const xess_vk_init_params_t,
    ) -> xess_result_t {
        (self.xessVKInit)(hContext, pInitParams)
    }
    #[doc = " @brief Get XeSS VK initialization parameters.\n\n @note This function will return @ref XESS_RESULT_ERROR_UNINITIALIZED if @ref xessVKInit has not been called.\n\n @param hContext: The XeSS context handle.\n @param[out] pInitParams: Returned initialization parameters.\n @return XeSS return status code."]
    pub unsafe fn xessVKGetInitParams(
        &self,
        hContext: xess_context_handle_t,
        pInitParams: *mut xess_vk_init_params_t,
    ) -> xess_result_t {
        (self.xessVKGetInitParams)(hContext, pInitParams)
    }
    #[doc = " @brief Record XeSS upscaling commands into the command list.\n @param hContext: The XeSS context handle.\n @param commandBuffer: The command bufgfer for XeSS commands.\n @param pExecParams: Execution parameters.\n @return XeSS return status code."]
    pub unsafe fn xessVKExecute(
        &self,
        hContext: xess_context_handle_t,
        commandBuffer: VkCommandBuffer,
        pExecParams: *const xess_vk_execute_params_t,
    ) -> xess_result_t {
        (self.xessVKExecute)(hContext, commandBuffer, pExecParams)
    }
    #[doc = " @addtogroup xess-vk-debug XeSS Vulkan API debug exports\n @{\n/\n/**\n @brief Query XeSS model to retrieve internal resources marked for dumping for further\n debug and inspection.\n @param hContext: The XeSS context handle.\n @param pResourcesToDump: Pointer to user-provided pointer to structure to be filled with\n debug resource array, their names and recommended dumping parameters. pResourcesToDump must not be null,\n In case of failure (xess_result_t is not equal to XESS_RESULT_SUCCESS) **pResourcesToDump contents is undefined and must not be used.\n In case of success, *pResourcesToDump may still be null, if no internal resources were added to dumping queue.\n Build configuration for certain implementations may have dumping functionality compiled-out and XESS_RESULT_ERROR_NOT_IMPLEMENTED return code.\n @return XeSS return status code."]
    pub unsafe fn xessVKGetResourcesToDump(
        &self,
        hContext: xess_context_handle_t,
        pResourcesToDump: *mut *mut xess_vk_resources_to_dump_t,
    ) -> xess_result_t {
        (self.xessVKGetResourcesToDump)(hContext, pResourcesToDump)
    }
}
