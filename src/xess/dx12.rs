/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xess_resources_to_dump_t {
    #[doc = " Total resource count. In case it equal to zero content of other structure members is undefined."]
    pub resource_count: u32,
    #[doc = " Pointer to an internal array of D3D12 resources. Array length is `resource_count`."]
    pub resources: *const *mut ID3D12Resource,
    #[doc = " Pointer to an internal array of D3D12 resource names. Array length is `resource_count`."]
    pub resource_names: *const *const ::std::os::raw::c_char,
    pub as_tensor: *const u32,
    pub border_pixels_to_skip_count: *const u32,
    pub tensor_channel_count: *const u32,
    pub tensor_width: *const u32,
    pub tensor_height: *const u32,
}
impl Default for _xess_resources_to_dump_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xess_resources_to_dump_t = _xess_resources_to_dump_t;
#[doc = " @brief Execution parameters for XeSS D3D12."]
#[repr(C)]
pub struct _xess_d3d12_execute_params_t {
    #[doc = " Input color texture. Must be in NON_PIXEL_SHADER_RESOURCE state."]
    pub pColorTexture: *mut ID3D12Resource,
    #[doc = " Input motion vector texture. Must be in NON_PIXEL_SHADER_RESOURCE state."]
    pub pVelocityTexture: *mut ID3D12Resource,
    #[doc = " Optional depth texture. Required if XESS_INIT_FLAG_HIGH_RES_MV has not been specified.\n Must be in NON_PIXEL_SHADER_RESOURCE state."]
    pub pDepthTexture: *mut ID3D12Resource,
    #[doc = " Optional 1x1 exposure scale texture. Required if XESS_INIT_FLAG_EXPOSURE_TEXTURE has been\n specified. Must be in NON_PIXEL_SHADER_RESOURCE state"]
    pub pExposureScaleTexture: *mut ID3D12Resource,
    #[doc = " Optional responsive pixel mask texture. Required if XESS_INIT_FLAG_RESPONSIVE_PIXEL_MASK\n has been specified. Must be in NON_PIXEL_SHADER_RESOURCE state"]
    pub pResponsivePixelMaskTexture: *mut ID3D12Resource,
    #[doc = " Output texture in target resolution. Must be in UNORDERED_ACCESS state."]
    pub pOutputTexture: *mut ID3D12Resource,
    #[doc = " Jitter X coordinate in the range [-0.5, 0.5]."]
    pub jitterOffsetX: f32,
    #[doc = " Jitter Y coordinate in the range [-0.5, 0.5]."]
    pub jitterOffsetY: f32,
    #[doc = " Optional input color scaling. Default is 1."]
    pub exposureScale: f32,
    #[doc = " Resets the history accumulation in this frame."]
    pub resetHistory: u32,
    #[doc = " Input color width."]
    pub inputWidth: u32,
    #[doc = " Input color height."]
    pub inputHeight: u32,
    #[doc = " Base coordinate for the input color in the texture. Default is (0,0)."]
    pub inputColorBase: xess_coord_t,
    #[doc = " Base coordinate for the input motion vector in the texture.  Default is (0,0)."]
    pub inputMotionVectorBase: xess_coord_t,
    #[doc = " Base coordinate for the input depth in the texture. Default is (0,0)."]
    pub inputDepthBase: xess_coord_t,
    #[doc = " Base coordinate for the input responsive pixel mask in the texture. Default is (0,0)."]
    pub inputResponsiveMaskBase: xess_coord_t,
    #[doc = " Reserved parameter."]
    pub reserved0: xess_coord_t,
    #[doc = " Base coordinate for the output color.  Default is (0,0)."]
    pub outputColorBase: xess_coord_t,
    #[doc = " Optional external descriptor heap."]
    pub pDescriptorHeap: *mut ID3D12DescriptorHeap,
    #[doc = " Offset in external descriptor heap in bytes."]
    pub descriptorHeapOffset: u32,
}
impl Default for _xess_d3d12_execute_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Execution parameters for XeSS D3D12."]
pub type xess_d3d12_execute_params_t = _xess_d3d12_execute_params_t;
#[doc = " @brief Initialization parameters for XeSS D3D12."]
#[repr(C)]
pub struct _xess_d3d12_init_params_t {
    #[doc = " Output width and height."]
    pub outputResolution: xess_2d_t,
    #[doc = " Quality setting"]
    pub qualitySetting: xess_quality_settings_t,
    #[doc = " Initialization flags."]
    pub initFlags: u32,
    #[doc = " Specifies the node mask for internally created resources on\n multi-adapter systems."]
    pub creationNodeMask: u32,
    #[doc = " Specifies the node visibility mask for internally created resources\n on multi-adapter systems."]
    pub visibleNodeMask: u32,
    #[doc = " Optional externally allocated buffer storage for XeSS. If NULL the\n storage is allocated internally. If allocated, the heap type must be\n D3D12_HEAP_TYPE_DEFAULT. This heap is not accessed by the CPU."]
    pub pTempBufferHeap: *mut ID3D12Heap,
    #[doc = " Offset in the externally allocated heap for temporary buffer storage."]
    pub bufferHeapOffset: u64,
    #[doc = " Optional externally allocated texture storage for XeSS. If NULL the\n storage is allocated internally. If allocated, the heap type must be\n D3D12_HEAP_TYPE_DEFAULT. This heap is not accessed by the CPU."]
    pub pTempTextureHeap: *mut ID3D12Heap,
    #[doc = " Offset in the externally allocated heap for temporary texture storage."]
    pub textureHeapOffset: u64,
    #[doc = " Pointer to pipeline library. If not NULL will be used for pipeline caching."]
    pub pPipelineLibrary: *mut ID3D12PipelineLibrary,
}
impl Default for _xess_d3d12_init_params_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Initialization parameters for XeSS D3D12."]
pub type xess_d3d12_init_params_t = _xess_d3d12_init_params_t;
pub struct Functions {
    __library: ::libloading::Library,
    pub xessD3D12GetResourcesToDump: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pResourcesToDump: *mut *mut xess_resources_to_dump_t,
    ) -> xess_result_t,
    pub xessD3D12GetProfilingData: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pProfilingData: *mut *mut xess_profiling_data_t,
    ) -> xess_result_t,
    pub xessD3D12CreateContext: unsafe extern "C" fn(
        pDevice: *mut ID3D12Device,
        phContext: *mut xess_context_handle_t,
    ) -> xess_result_t,
    pub xessD3D12BuildPipelines: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pPipelineLibrary: *mut ID3D12PipelineLibrary,
        blocking: bool,
        initFlags: u32,
    ) -> xess_result_t,
    pub xessD3D12Init: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pInitParams: *const xess_d3d12_init_params_t,
    ) -> xess_result_t,
    pub xessD3D12GetInitParams: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pInitParams: *mut xess_d3d12_init_params_t,
    ) -> xess_result_t,
    pub xessD3D12Execute: unsafe extern "C" fn(
        hContext: xess_context_handle_t,
        pCommandList: *mut ID3D12GraphicsCommandList,
        pExecParams: *const xess_d3d12_execute_params_t,
    ) -> xess_result_t,
}
impl Functions {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let xessD3D12GetResourcesToDump = __library
            .get(b"xessD3D12GetResourcesToDump\0")
            .map(|sym| *sym)?;
        let xessD3D12GetProfilingData = __library
            .get(b"xessD3D12GetProfilingData\0")
            .map(|sym| *sym)?;
        let xessD3D12CreateContext = __library.get(b"xessD3D12CreateContext\0").map(|sym| *sym)?;
        let xessD3D12BuildPipelines = __library
            .get(b"xessD3D12BuildPipelines\0")
            .map(|sym| *sym)?;
        let xessD3D12Init = __library.get(b"xessD3D12Init\0").map(|sym| *sym)?;
        let xessD3D12GetInitParams = __library.get(b"xessD3D12GetInitParams\0").map(|sym| *sym)?;
        let xessD3D12Execute = __library.get(b"xessD3D12Execute\0").map(|sym| *sym)?;
        Ok(Functions {
            __library,
            xessD3D12GetResourcesToDump,
            xessD3D12GetProfilingData,
            xessD3D12CreateContext,
            xessD3D12BuildPipelines,
            xessD3D12Init,
            xessD3D12GetInitParams,
            xessD3D12Execute,
        })
    }
    #[doc = " @addtogroup xess-d3d12-debug XeSS D3D12 API debug exports\n @{\n/\n/**\n @brief Query XeSS model to retrieve internal resources marked for dumping for further\n debug and inspection.\n @param hContext: The XeSS context handle.\n @param pResourcesToDump: Pointer to user-provided pointer to structure to be filled with\n debug resource array, their names and recommended dumping parameters. pResourcesToDump must not be null,\n In case of failure (xess_result_t is not equal to XESS_RESULT_SUCCESS) **pResourcesToDump contents is undefined and must not be used.\n In case of success, *pResourcesToDump may still be null, if no internal resources were added to dumping queue.\n Build configuration for certain implementations may have dumping functionality compiled-out and XESS_RESULT_ERROR_NOT_IMPLEMENTED return code.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12GetResourcesToDump(
        &self,
        hContext: xess_context_handle_t,
        pResourcesToDump: *mut *mut xess_resources_to_dump_t,
    ) -> xess_result_t {
        (self.xessD3D12GetResourcesToDump)(hContext, pResourcesToDump)
    }
    #[doc = " @brief Query XeSS model performance data for past executions.\n This function is provided for backwards compatibility with previous XeSS versions and\n and it's currently deprecated. Same functionality is provided by xessGetProfilingData\n function from xess_debug.h. To enable performance collection,\n context must be initialized with XESS_DEBUG_ENABLE_PROFILING flag added to xess_d3d12_init_params_t::initFlags.\n If profiling is enabled, user must poll for profiling data after executing one or more command lists, otherwise\n implementation will keep growing internal CPU buffers to accommodate all profiling data available.\n Due to async nature of execution on GPU, data may not be available after submitting command lists to device queue.\n It is advised to check `any_profiling_data_in_flight` flag in case all workloads has been submitted, but profiling\n data for some frames is still not available.\n Data pointed to by pProfilingData item(s) belongs to context instance and\n is valid until next call to xessD3D12GetProfilingData or xessGetProfilingData for owning context.\n @param hContext: The XeSS context handle.\n @param pProfilingData: pointer to profiling data structure to be filled by implementation.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12GetProfilingData(
        &self,
        hContext: xess_context_handle_t,
        pProfilingData: *mut *mut xess_profiling_data_t,
    ) -> xess_result_t {
        (self.xessD3D12GetProfilingData)(hContext, pProfilingData)
    }
    #[doc = " @addtogroup xess-d3d12 XeSS D3D12 API exports\n @{\n/\n/**\n @brief Create an XeSS D3D12 context.\n @param pDevice: A D3D12 device created by the user.\n @param[out] phContext: Returned xess context handle.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12CreateContext(
        &self,
        pDevice: *mut ID3D12Device,
        phContext: *mut xess_context_handle_t,
    ) -> xess_result_t {
        (self.xessD3D12CreateContext)(pDevice, phContext)
    }
    #[doc = " @brief Initiates pipeline build process\n This function can only be called between @ref xessD3D12CreateContext and\n @ref xessD3D12Init\n This call initiates build of DX12 pipelines and kernel compilation\n This call can be blocking (if @p blocking set to true) or non-blocking.\n In case of non-blocking call library will wait for pipeline build on call to\n @ref xessD3D12Init\n If @p pPipelineLibrary passed to this call - same pipeline library must be passed\n to @ref xessD3D12Init\n\n @param hContext The XeSS context handle.\n @param pPipelineLibrary Optional pointer to pipeline library for pipeline caching.\n @param blocking Wait for kernel compilation and pipeline creation to finish or not\n @param initFlags Initialization flags. *Must* be identical to flags passed to @ref xessD3D12Init"]
    pub unsafe fn xessD3D12BuildPipelines(
        &self,
        hContext: xess_context_handle_t,
        pPipelineLibrary: *mut ID3D12PipelineLibrary,
        blocking: bool,
        initFlags: u32,
    ) -> xess_result_t {
        (self.xessD3D12BuildPipelines)(hContext, pPipelineLibrary, blocking, initFlags)
    }
    #[doc = " @brief Initialize XeSS D3D12.\n This is a blocking call that initializes XeSS and triggers internal\n resources allocation and JIT for the XeSS kernels. The user must ensure that\n any pending command lists are completed before re-initialization. When\n During initialization, XeSS can create staging buffers and copy queues to\n upload internal data. These will be destroyed at the end of initialization.\n\n @note XeSS supports devices starting from D3D12_RESOURCE_HEAP_TIER_1, which means\n that buffers and textures can not live in the same resource heap.\n\n @param hContext: The XeSS context handle.\n @param pInitParams: Initialization parameters.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12Init(
        &self,
        hContext: xess_context_handle_t,
        pInitParams: *const xess_d3d12_init_params_t,
    ) -> xess_result_t {
        (self.xessD3D12Init)(hContext, pInitParams)
    }
    #[doc = " @brief Get XeSS D3D12 initialization parameters.\n\n @note This function will return @ref XESS_RESULT_ERROR_UNINITIALIZED if @ref xessD3D12Init has not been called.\n\n @param hContext: The XeSS context handle.\n @param[out] pInitParams: Returned initialization parameters.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12GetInitParams(
        &self,
        hContext: xess_context_handle_t,
        pInitParams: *mut xess_d3d12_init_params_t,
    ) -> xess_result_t {
        (self.xessD3D12GetInitParams)(hContext, pInitParams)
    }
    #[doc = " @brief Record XeSS upscaling commands into the command list.\n @param hContext: The XeSS context handle.\n @param pCommandList: The command list for XeSS commands.\n @param pExecParams: Execution parameters.\n @return XeSS return status code."]
    pub unsafe fn xessD3D12Execute(
        &self,
        hContext: xess_context_handle_t,
        pCommandList: *mut ID3D12GraphicsCommandList,
        pExecParams: *const xess_d3d12_execute_params_t,
    ) -> xess_result_t {
        (self.xessD3D12Execute)(hContext, pCommandList, pExecParams)
    }
}
